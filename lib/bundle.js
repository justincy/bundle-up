// Generated by CoffeeScript 1.4.0
(function() {
  var Bundle, async, compiler, crypto, fileExistSync, fs, normalizeUrl, path, writeToFile, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  crypto = require('crypto');

  path = require('path');

  compiler = require('./compiler');

  fs = require('fs');

  async = require('async');

  _ref = require('./helpers'), writeToFile = _ref.writeToFile, normalizeUrl = _ref.normalizeUrl, fileExistSync = _ref.fileExistSync;

  Bundle = (function() {

    function Bundle(options) {
      this.options = options;
      this._compile = __bind(this._compile, this);

      this.toBundles = __bind(this.toBundles, this);

      this._addUrl = __bind(this._addUrl, this);

      this.addObject = __bind(this.addObject, this);

      this.addUrl = __bind(this.addUrl, this);

      this.addFile = __bind(this.addFile, this);

      this._getRelativePath = __bind(this._getRelativePath, this);

      this.options.staticRoot = path.normalize(this.options.staticRoot);
      this.files = [];
      this.defaultCompiledDir = 'min';
      this.defaultNamespace = 'global';
    }

    Bundle.prototype._getRelativePath = function(file) {
      var char, i, relativePath, _i, _len;
      relativePath = '';
      for (i = _i = 0, _len = file.length; _i < _len; i = ++_i) {
        char = file[i];
        if (this.options.staticRoot[i] === file[i]) {
          continue;
        } else {
          relativePath = file.substring(i);
          break;
        }
      }
      return relativePath;
    };

    Bundle.prototype._needsCompiling = function(file) {
      var fileExt;
      fileExt = file.split('.');
      fileExt = fileExt[fileExt.length - 1];
      return fileExt !== 'js' && fileExt !== 'css';
    };

    Bundle.prototype.addFilesBasedOnFilter = function(filterPath, namespace) {
      var directoryFind, directoryPath, file, foundFiles, searchFiles, searchNested, _i, _len, _results;
      directoryPath = filterPath.substring(0, filterPath.indexOf('*'));
      searchFiles = filterPath.substring(filterPath.indexOf('*.') + 1);
      if (searchFiles === filterPath) {
        searchFiles = void 0;
      }
      searchNested = filterPath.indexOf('**') > -1;
      foundFiles = [];
      directoryFind = function(dir, retrying) {
        var closestDir, file, files, _i, _len, _results;
        if (retrying == null) {
          retrying = false;
        }
        try {
          files = fs.readdirSync(dir);
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            file = dir + '/' + file;
            if (!fs.lstatSync(file).isDirectory()) {
              if (searchFiles) {
                if (file.indexOf(searchFiles) > -1) {
                  _results.push(foundFiles.push(file));
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(foundFiles.push(file));
              }
            } else if (searchNested) {
              _results.push(directoryFind(file));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } catch (err) {
          if (err.code === 'ENOENT') {
            if (!retrying) {
              closestDir = dir.split('/');
              dir = closestDir.splice(0, closestDir.length - 1).join('/');
              searchFiles = dir + '/' + closestDir.splice(closestDir.length - 1).join('');
              searchNested = true;
              return directoryFind(dir, true);
            } else {

            }
          } else {
            return console.log(err);
          }
        }
      };
      directoryFind(directoryPath);
      foundFiles = foundFiles.sort();
      _results = [];
      for (_i = 0, _len = foundFiles.length; _i < _len; _i++) {
        file = foundFiles[_i];
        _results.push(this.addFile(file, namespace));
      }
      return _results;
    };

    Bundle.prototype.addFile = function(file, namespace) {
      var f, needsCompiling, origFile, relativeFile, url, writeTo, _i, _len, _ref1;
      if (namespace == null) {
        namespace = this.defaultNamespace;
      }
      file = path.normalize(file);
      _ref1 = this.files;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        f = _ref1[_i];
        if (file === f.origFile && namespace === f.namespace) {
          return;
        }
      }
      if (file.indexOf('*') > -1) {
        return this.addFilesBasedOnFilter(file, namespace);
      }
      relativeFile = this._getRelativePath(file);
      origFile = file;
      needsCompiling = false;
      if (file.indexOf(this.options.staticRoot) === -1 || this._needsCompiling(file)) {
        writeTo = path.normalize(this._convertFilename("" + this.options.staticRoot + "/" + this.defaultCompiledDir + "/" + relativeFile));
        needsCompiling = true;
        file = writeTo;
        relativeFile = this._getRelativePath(file);
      }
      url = this.options.staticUrlRoot + relativeFile;
      url = normalizeUrl(url);
      return this.files.push({
        url: url,
        file: file,
        origFile: origFile,
        needsCompiling: needsCompiling,
        namespace: namespace
      });
    };

    Bundle.prototype.addUrl = function(url, namespace) {
      if (namespace == null) {
        namespace = this.defaultNamespace;
      }
      return this._addUrl(url, namespace, true);
    };

    Bundle.prototype.addObject = function(object, namespace) {
      if (namespace == null) {
        namespace = this.defaultNamespace;
      }
      if (typeof object === !"object") {
        throw new Error(".addObject(object, ...) must be an object");
      }
      return this.files.push({
        url: {},
        file: object,
        origFile: null,
        needsCompiling: false,
        namespace: namespace
      });
    };

    Bundle.prototype._addUrl = function(url, namespace, isFromPublicAPI) {
      if (namespace == null) {
        namespace = this.defaultNamespace;
      }
      if (isFromPublicAPI == null) {
        isFromPublicAPI = false;
      }
      return this.files.push({
        url: isFromPublicAPI ? true : url,
        file: url,
        origFile: url,
        needsCompiling: false,
        namespace: namespace
      });
    };

    Bundle.prototype.toBundles = function(fnToBundleDone) {
      var bundles, compileBundle, file, files, _i, _len, _ref1, _ref2,
        _this = this;
      fnToBundleDone = fnToBundleDone || function() {};
      compileBundle = function(files, namespace, fnCompileDone) {
        var complete, fileIterator, specialFiles, str;
        str = '';
        specialFiles = [];
        files = files.filter(function(file) {
          return file.namespace === namespace;
        });
        fileIterator = function(file, cb) {
          if (typeof file.url === "object" || typeof file.url === "boolean") {
            specialFiles.push(file.file);
            return cb(null, void 0);
          } else if (typeof file.url === "string") {
            return _this._compile(file.origFile, file.file, function(err, content) {
              return cb(err, content.trim('\n'));
            });
          }
        };
        complete = function(err, results) {
          var filepath, hash, specialFile, _i, _len;
          if (err) {
            throw new Error("compileBundle " + err);
          }
          results = results.filter(function(o) {
            return typeof o !== "undefined";
          });
          str = results.join(_this.fileExtension === '.css' ? '\n' : ';\n');
          hash = crypto.createHash('md5').update(str).digest('hex');
          filepath = "" + _this.options.staticRoot + "/" + _this.defaultCompiledDir + "/bundle/" + (hash.substring(0, 7)) + "_" + namespace + _this.fileExtension;
          for (_i = 0, _len = specialFiles.length; _i < _len; _i++) {
            specialFile = specialFiles[_i];
            if (typeof specialFile === "object") {
              _this.addObject(specialFile, namespace);
            } else {
              _this._addUrl(specialFile, namespace);
            }
          }
          if (results.length > 0) {
            if (fileExistSync(filepath)) {

            } else {
              str = _this.minify(str);
              writeToFile(filepath, str);
            }
            _this.addFile(filepath, namespace);
          }
          return fnCompileDone();
        };
        return async.map(files, fileIterator, complete);
      };
      bundles = [];
      _ref1 = this.files;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        if (_ref2 = file.namespace, __indexOf.call(bundles, _ref2) < 0) {
          bundles.push(file.namespace);
        }
      }
      files = this.files;
      this.files = [];
      return async.forEach(bundles, compileBundle.bind(this, files), fnToBundleDone);
    };

    Bundle.prototype._compile = function(file, writeTo, cb) {
      return compiler.compileFile(this.options.compilers, file, function(err, content) {
        if (err != null) {
          throw err;
        }
        writeToFile(writeTo, content);
        return cb(null, content);
      });
    };

    return Bundle;

  })();

  module.exports = Bundle;

}).call(this);
